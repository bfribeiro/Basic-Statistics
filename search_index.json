[
["index.html", "Basic Statistics With R Preface", " Basic Statistics With R Bruno Ribeiro 2018-07-16 Preface This book is intended to cover the basic aspects of statistics, probability and inference, in association with R, a free software environment for statistical computing. It relies mostly on lecture notes from several classes on statistics, probability and data science and, for such, it intends to be somehow more simplistic and easy to understand. This book will be divided into three parts: Probability Statistics Inference Most part of this book will use problems to present the concepts and, only then, define them. For this reason, there will be several examples and exercises for each topic. But, don’t worry, all the answers and explanations can be found at the end of it. However, as it is entitled, this book is not supposed to be an exhaustive work on the subjects, but it will try to explain the concepts that will make it easier to look for additional information elsewhere. Note that, although R is used throughout this book, it will not focus on R basics. Nevertheless, the commands used here will be, somehow, explained. "],
["introduction.html", "Introduction", " Introduction Why do I need to study statistics? That’s a very common question for those who don’t like mathematics or any of its related fields. However, statistics are very related to our lives and to understand its concepts can provide very useful insights about how to deal with uncertainty. Insurance, bank loans, weather prediction, sport bets and strategy, etc., they are all strictly related to probability and statistics. It is important to note that, although colloquially used as synonyms, probability and statistics are not the same subjects. While probability is a mathematics field that measures the likelihood that an event will occur, statistics use probability theories to explain the occurrence of such event. Simply put, probability and statistics are complementary subjects. Why R? R is a free software environment for statistical computing development in the numeric analysis and machine learning spaces. It’s easy to program, allows you to create reproducible, high-quality analysis. It has a wonderful flexibility and power for dealing with data. It provides a wide variety of statistical and graphical techniques, and there’s a lot of functionality that’s built in that’s built for statisticians. Its package ecosystem is extremally vast and it runs across all major platforms (Windows, Mac OS and UNIX/Linux), and scripts and data can be shared across these platforms seamlessly. Also, there is a large, growing, and active community of R users and, as a result, there are numerous resources for learning and asking questions. If a statistical technique exists, in any field, odds are there’s already an R package out there for it. "],
["installing-r-and-rstudio.html", "Installing R and RStudio", " Installing R and RStudio Installing R As previously said, R is a free software that is available for Windows, Mac OS and UNIX/Linux. It can be downloaded from The Comprehensive R Archive Network - CRAN, but the links for each operational system are provided below. Windows: https://cran.r-project.org/bin/windows/base/ Mac OS: https://cran.r-project.org/bin/macosx/ UNIX/Linux: https://cran.r-project.org/bin/linux/ The installation is pretty straight forward and you shall not encounter any problem, but if you need any help, please, follow the links below. Windows: https://github.com/genomicsclass/windows#installing-r Mac OS: http://youtu.be/Icawuhf0Yqo UNIX/Linux: http://cran.r-project.org/bin/linux/ubuntu/README Installing RStudio RStudio is a integrated development environment, IDE for short, for R. It provides an organized interface so that you can clearly view graphs, data tables, R code, and output all at the same time. The download for all platforms can be found in https://www.rstudio.com/products/rstudio/download/#download. Note that you need to install R prior to RStudio. As R, the installation is pretty straight forward. However, for Windows users, the link provided as help for installing R also explains the steps necessary for RStudio. Sources for learning R As it was said before, this is not a textbook for learning R. Although it is not required prior knowledge about it, having previous contact with the language makes things easier. Anyway, the basics to understand what is presented in this book will be explained throughout it, when needed. You can learn more about R in the following links: R for Beginners - CRAN-R - R Project: It is a document created by Emmanuel Paradis that focus, as he wrote, on giving a starting point for people nearly interested in R and that emphasize on the understanding of how R works. (For those reading in PDF you can find it in: https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf). R Tutorial: A simple and direct web tutorial for R and quite good for those who just want to learn the very basics to no get “lost” while going through this book (https://www.statmethods.net/r-tutorial/index.html). YaRrr! The Pirate’s Guide to R: It’s a great book, free and that is meant to introduce the basic analytical tools in R, from basic coding and analyses, to data wrangling, plotting, and statistical inference (https://bookdown.org/ndphillips/YaRrr/). Of course, there are some other sources that, even not being directed toward R itself, it explains the very basic concepts in a very simple way: Introduction to Data Science: These are the class notes used in the HarvardX Data Science Series, written by Rafael A. Irizarry. They are very straight put and can give you a valuable insight if you’re in a hurry. Also, as it is part of a Professional Certificate Program, the classes can be accessed on edX website(https://www.edx.org/course/data-science-r-basics). You can enroll for free, if you don’t want a certificate. Just need to sign up. R for Data Science: It’s a more in-depth book, written by Garrett Grolemund and Hadley Wickham. Since it’s focused on Data Science, for those who want to learn more about R and Data Science (http://r4ds.had.co.nz/). "],
["introduction-1.html", "Chapter 1 Introduction", " Chapter 1 Introduction There are two phenomena that can be found in nature: Deterministic – those for which results will not vary, it doesn’t matter how many times you repeat an experiment; and Random – those for which results cannot be predicted, it doesn’t matter how many observations you’ve made before. As an example, for both cases, imagine that you’re walking down the street and it starts to rain and, as usual, you are not carrying an umbrella. With no place to take cover, you certainly get wet. Simply put, that is a deterministic event. On the other hand, when the morning news presented the weather forecast, it was said to have 80% chances of raining. But you didn’t see it cause, as usual, you were running late for work (which actually wouldn’t matter that much, if you’re like me, you’d have forgotten the umbrella anyway). Weather forecasting is an example of a random event. Based on previous knowledge, of certain parameters which we will no talk about here, you can estimate that “is possible to rain” but you can’t say that “you are sure”. ‘What are the odds of that happening?’; ‘What are the chances of winning in the lottery?’; ‘Who will be the next president?’. Probability talks about this type of questions. It talks about the analysis of random phenomena. You can call it uncertainty, chances, percentage, proportion, likelihood… but in the end, they are all just random phenomena that we are trying to understand. In other words, probability is the long-term chance that a certain outcome will occur, given some random process. (Note that, probability consists of a number between 0 (impossibility) and 1 (total certainty) – or 0% and 100%, if you like.) Getting back to our random events, it’s important to keep in mind that even if the initial conditions are always the same, the final results of each trial will be, theoretically, different. \\(~\\) Random experiments and outcomes Random Experiment Random Event (outcome) Throw a coin Heads or tails Throw a 6-faced die 1,2,3,4,5 or 6 Draw a card out of a deck 2 to 10, J,Q,K or A As you can see, for every random experiment there is a result called random event. Important Notes Probability: Long-term chance that a certain outcome will occur, given some random process. Deterministic events: They are a constant. No matter how many times an experiment is repeated, the result is always the same. Random experiment: It’s an experiment, or phenonema, for which we don’t know the outcome. Random events: It’s something unpredictable.The outcome of a random experiment. "],
["sample-space.html", "Chapter 2 Sample Space", " Chapter 2 Sample Space When you toss a coin, there are two possible results: heads or tails. A die roll has six possible outcomes: 1,2,3,4,5 or 6. These sets correspond to every possible outcome for these both experiments.This is what we call Sample Space. A sample space is simply the set of all possible outcomes of an experiment. It may be defined as:\\(\\ \\Omega \\) or S.In this book, we will always be denoted as S. #Constructing a sample space for a coin and a die: S&lt;-c(&#39;Head&#39;, &#39;Tails&#39;) #These are de possible outcomes of a coin toss we attribute to #variable &#39;S&#39;. Note that if you specify multiple results you need to put c(&#39;value1&#39;, #&#39;value2&#39;,&#39;value...). #Text should always be between &#39;&#39;. S #This prints the variable &#39;S&#39; value to the screen. ## [1] &quot;Head&quot; &quot;Tails&quot; S&lt;-(1:6) #Attributing the sample space for a die. Note that when we assign the new #value to the variable &#39;S&#39;, its previous value is &#39;erased&#39;. S ## [1] 1 2 3 4 5 6 Keep in mind that a random event can be a single outcome or several outcomes. As an example, consider that two dice are rolled and describe the following events: same faces faces which the sum is equal to 10. faces which the sum is less than 2. faces which the sum is less than 15. First, let’s describe all the possible outcomes of a two dice roll: d1&lt;-1:6 #Dice 1 d2&lt;-1:6 #Dice 2 combine &lt;- function(..., prefix = &quot;(&quot;, suffix=&#39;)&#39;, sep = &quot;,&quot;) { paste0(prefix, levels(interaction(..., sep = sep)), suffix) } #This function is meant to create a cartesian product between the two dice. D&lt;-matrix(combine(d1,d2), nrow=6, ncol=6)#This will create a 6x6 matrix with all possible #results for the dice combination. #Both lines below are just to rename the matrix columns and rows as 1,2,3,4,5,6 #(number of faces of each die) colnames(D)&lt;-d1 rownames(D)&lt;-d2 D ## 1 2 3 4 5 6 ## 1 &quot;(1,1)&quot; &quot;(1,2)&quot; &quot;(1,3)&quot; &quot;(1,4)&quot; &quot;(1,5)&quot; &quot;(1,6)&quot; ## 2 &quot;(2,1)&quot; &quot;(2,2)&quot; &quot;(2,3)&quot; &quot;(2,4)&quot; &quot;(2,5)&quot; &quot;(2,6)&quot; ## 3 &quot;(3,1)&quot; &quot;(3,2)&quot; &quot;(3,3)&quot; &quot;(3,4)&quot; &quot;(3,5)&quot; &quot;(3,6)&quot; ## 4 &quot;(4,1)&quot; &quot;(4,2)&quot; &quot;(4,3)&quot; &quot;(4,4)&quot; &quot;(4,5)&quot; &quot;(4,6)&quot; ## 5 &quot;(5,1)&quot; &quot;(5,2)&quot; &quot;(5,3)&quot; &quot;(5,4)&quot; &quot;(5,5)&quot; &quot;(5,6)&quot; ## 6 &quot;(6,1)&quot; &quot;(6,2)&quot; &quot;(6,3)&quot; &quot;(6,4)&quot; &quot;(6,5)&quot; &quot;(6,6)&quot; From the matrix above you can see that there are 36 possible combinations as outcomes for rolling two dice. Once the matrix is ready, we can count the the requested outcomes. same faces \\(\\ A = \\){\\((1,1), (2,2), (3,3), (4,4), (5,5),(6,6)\\)} faces which the sum is equal to 10. \\(\\ B = \\){\\((4,6), (5,5), (6,4)\\)} faces which the sum is less than 2. \\(C= \\Phi \\) - (impossible event) faces which the sum is less than 15. \\(D= (S)\\) - (certain event) There are two things to be noted in the itens above: It’s impossible to pick up two faces which the sum is less than 2. It happens because the minor value possible for each die is 1, so the minor sum possible is 2. So the number of combinations that satisfies the question is 0. Pick up two faces which the sum is less than 15, is equal to the sample space S. That happens because the sum can be bigger than 12, so all the combinations will be inside this range. As it was mentioned before, probability consists of a number between 0 (impossibility) and 1 (total certainty) – or 0% and 100%. \\(P=(0 \\leq X \\leq 1)\\) "],
["power-set.html", "2.1 Power Set", " 2.1 Power Set Let’s take another look in the matrix for the outcomes of two dice roll. ## 1 2 3 4 5 6 ## 1 &quot;(1,1)&quot; &quot;(1,2)&quot; &quot;(1,3)&quot; &quot;(1,4)&quot; &quot;(1,5)&quot; &quot;(1,6)&quot; ## 2 &quot;(2,1)&quot; &quot;(2,2)&quot; &quot;(2,3)&quot; &quot;(2,4)&quot; &quot;(2,5)&quot; &quot;(2,6)&quot; ## 3 &quot;(3,1)&quot; &quot;(3,2)&quot; &quot;(3,3)&quot; &quot;(3,4)&quot; &quot;(3,5)&quot; &quot;(3,6)&quot; ## 4 &quot;(4,1)&quot; &quot;(4,2)&quot; &quot;(4,3)&quot; &quot;(4,4)&quot; &quot;(4,5)&quot; &quot;(4,6)&quot; ## 5 &quot;(5,1)&quot; &quot;(5,2)&quot; &quot;(5,3)&quot; &quot;(5,4)&quot; &quot;(5,5)&quot; &quot;(5,6)&quot; ## 6 &quot;(6,1)&quot; &quot;(6,2)&quot; &quot;(6,3)&quot; &quot;(6,4)&quot; &quot;(6,5)&quot; &quot;(6,6)&quot; This matrix, let’s name it DICE, represents all the possible combinations that can result as outcomes when we roll two dice. If we take, for example, the number of events for which the faces sum is equal to 10, \\(\\ B = \\){\\((4,6), (5,5), (6,4)\\)}, we can say that B is a subset of DICE, that is, all elements of B are also elements of DICE. Breaking it down: DICE is the Sample Space produced by rolling two dice. Sice all elements of B are also elements of DICE, B is a subset of DICE (It can also be said that DICE is a superset of B). To say that B is a subset of DICE or that DICE is a superset of B is equivalent to say that: \\(B \\subset DICE\\) or \\(DICE \\supset B\\). \\(~\\) The set of all possible combinations of DICE, including the empty set and the whole set DICE itself, is called power set. To illustrate the idea, let’s pick a finite sample space and decompose it into its subsets. Given a Sample Space S: \\(~\\) \\(S=\\{(e_1, e_2, e_3, e_4)\\}\\) \\(~\\) The classes of this random events can be determined as: \\(~\\) \\(F(S)= \\begin{Bmatrix} \\Phi \\\\ \\{e_1\\} , \\{e_2\\} , \\{e_3\\} , \\{e_4\\} \\\\ \\{e_1,e_2\\}, \\{e_1,e_3\\}, \\{e_1,e_4\\}, \\{e_2,e_3\\},\\{e_2,e_4\\}, \\{e_3,e_4\\}\\\\ \\{e_1,e_2,e_3\\}, \\{e_1,e_2,e_4\\},\\{e_1,e_3,e_4\\},\\{e_2,e_3,e_4\\}\\\\ \\{e_1,e_2,e_3,e_4\\} \\end{Bmatrix}\\) \\(~\\) For the number of elements (events) of \\(F(S)\\)to be determined we should note that: \\(~\\) \\(\\Phi\\) corresponds to \\(\\binom{4}{0}\\) \\(\\{e_1\\},...,\\{e_4\\}\\) corresponds to \\(\\binom{4}{1}\\) \\(\\{e_1,e_2\\},...,\\{e_3,e_4\\}\\) corresponds to \\(\\binom{4}{2}\\) \\(\\{e_1,e_2,e_3\\},...,\\{e_2,e_3,e_4\\}\\) corresponds to \\(\\binom{4}{3}\\) \\(\\{e_1,e_2,e_3,e_4\\}\\) corresponds to \\(\\binom{4}{4}\\) \\(~\\) That said, \\(n(F)=\\binom{4}{0}+ \\binom{4}{1}+ \\binom{4}{2}+ \\binom{4}{3}+ \\binom{4}{4}= 16\\) \\(~\\) Generally speaking, if the number of samples of a finite sample space is given by \\(n\\), then its power set is given \\(2^{n}\\). It means that: \\(~\\) \\(n(F)=\\binom{4}{0}+ \\binom{4}{1}+ \\binom{4}{2}+ \\binom{4}{3}+ \\binom{4}{4}= 2^{4}=16\\) \\(~\\) 2.1.1 Binomial Coefficient Considering that some people are not very familiar with math, let me explain the meaning of all \\(\\binom{n}{k}\\) above. Suppose you have three fruits: \\(fruits=\\{apple, orange, banana\\}\\) and you want to know how many combinations of two fruits you can pick, considering that the order does not matter (we will talk about this later). You can write it down like this: \\((fruits-taken-2x2)= \\begin{Bmatrix} \\{apple, orange\\}\\\\ \\{apple, banana\\}\\\\ \\{orange, banana\\}\\\\ \\end{Bmatrix}\\) \\(~\\) There are only three ways for which you can choose 2 out of 3 fruits. Since the fruits set is small it’s easy to write the whole possible combinations without any effort. However, when sets get too large, it becames impractical to write it down. Let’s make it bigger. Let’s pick a 52 card deck. A poker hand has 5 cards. The 5 cards are all distinct (remember that you have 4 suits - hearts, diamonds, spades and clubs. For each suit you have 9 numbered cards - 2 to 10 -, three figures - jack, queen and king - and an ace). Although the order of the cards does not matter, there’s no repetition of each card. You can try to write down all combinations possible, but I assure you that it will take a very, very long time. To solve this problem and make its solving faster we use what is called binomial coefficient. Binomial coefficient corresponds to the number of ways of picking k unordered outcomes from n possibilities, also known as a combination (sometimes referred to as combinatorial) and it’s given by: \\(\\binom{n}{k}\\) - we say that “n chooses k”. In our fruits example, instead of writing down every possible outcome for then count it, we would use the binomial coefficient to give us the final value. But how do we calculate it? The value of the binomial coefficient for nonnegative \\(n\\) and \\(k\\) is given explicitly by: \\(~\\) \\(\\large\\ \\binom{n}{k}=\\frac{n!}{k!(n-k)!}\\) \\(~\\) Going back to our fruits example, we have three fruits take 2 by 2: \\(~\\) \\(\\large\\ \\binom{3}{2}=\\frac{3!}{2!(3-2)!} \\therefore \\frac{3 \\times 1}{2 \\times 1 \\times (1)!} \\therefore \\frac{6}{2}=3\\) \\(~\\) However, as said before, this set is so small that use binomial coeffient to see how many combinations are possible takes more time than simply writing and checking it. So, let’s take the 5 card poker hand out of a 52 card deck. \\(~\\) There are 52 card and we want 5 cards. So, \\(n=52\\) and \\(k=5\\). Our binomial coefficient is given by: \\(^{52}C_5=\\binom{52}{5}\\). \\(~\\) \\(^{52}C_5= \\binom{52}{5} = \\frac{52!}{5!(52 - 5)!} \\therefore \\frac{52 \\times 51 \\times 50 \\times 49 \\times 48 \\times 47}{5! \\times (47!)} \\therefore \\frac{52 \\times 51 \\times 50 \\times 49 \\times 48}{5 \\times 4 \\times 3 \\times 2 \\times 1} \\therefore \\frac{311,875,200}{120}=2,598,960\\) \\(~\\) There are 2,598,960 possible combinations. (I tould you it would take a very, very long time to write down every possible combination). \\(~\\) However, R has an inbuilt funcion called ‘choose’ that performs this calculations easily: #For the fruits fruits_combinations&lt;-choose(3,2) fruits_combinations ## [1] 3 #For the poker hand poker_hand&lt;-choose(52,5) poker_hand ## [1] 2598960 "],
["set-operations.html", "2.2 Set Operations", " 2.2 Set Operations Once again, let’s consider a finite sample space \\(S=\\{e_1,e_2,e_3,...,e_n\\}\\) and let’s make \\(A\\) and \\(B\\) two events of \\(F(S)\\). From that, we can state the following definitions: 2.2.1 Union The event union is composed by the elements which are in \\(A\\), in \\(B\\), or in both \\(A\\) and \\(B\\). in other words, the elements belong to, at least, one of the two sets. It is represented by \\(A \\cup B\\). In mathematical words, Its anny element that belongs to the sample space such as this element belongs to set \\(A\\) or to set \\(B\\): \\(\\{A \\cup B = e_i \\in S | e_i \\in A\\) or \\(e_i \\in B\\}\\). The union between two sets can be easily computed in R using the “union” function. A&lt;-c(&quot;shirt&quot;, &quot;shoes&quot;, &quot;laces&quot;) #Defining set A B&lt;-c(&quot;jacket&quot;, &quot;trousers&quot;, &quot;laces&quot;) #Defining set B AUB&lt;-union(A,B) AUB ## [1] &quot;shirt&quot; &quot;shoes&quot; &quot;laces&quot; &quot;jacket&quot; &quot;trousers&quot; It should be noted that the “union” funcion can only unite two sets at a time. So if we have three sets, \\(A, B\\) and \\(C\\), we would have to perform the operation twice. A&lt;-c(&quot;shirt&quot;, &quot;shoes&quot;, &quot;laces&quot;) #Defining set A B&lt;-c(&quot;jacket&quot;, &quot;trousers&quot;, &quot;laces&quot;) #Defining set B C&lt;-c(&quot;shirt&quot;, &quot;socks&quot;, &quot;skirt&quot;, &quot;shirt&quot;) #Defining set C AUB&lt;-union(A,B) #Defining the variable which will &quot;receive&quot;&quot; the union AUB ## [1] &quot;shirt&quot; &quot;shoes&quot; &quot;laces&quot; &quot;jacket&quot; &quot;trousers&quot; AUBUC&lt;-union(AUB, C) AUBUC ## [1] &quot;shirt&quot; &quot;shoes&quot; &quot;laces&quot; &quot;jacket&quot; &quot;trousers&quot; &quot;socks&quot; ## [7] &quot;skirt&quot; Although the sum of the elements is 10 (\\(A=3\\), \\(B=3\\), \\(C=4\\)), the total elements of the union \\((A \\cup B \\cup C)\\) has only seven elements. That happens because it doesn’t count repeated elements. 2.2.2 Intersection The event intersection is composed by elements that belongs simultaneously to \\(A\\) and \\(B\\). It simply what they have in common. It’s represented by \\(A \\cap B\\). In a more technical dialet, the intersection between two sets is composed by any element of the sample space that belongs to \\(A\\) and belongs to \\(B\\): \\(A \\cap B = \\{e_i \\in S | e_i \\in A\\) and \\(e_i \\in B\\}\\). So as the “union” function, there is also an “intersect”&quot; function in-built in R. Let’s take the same sets \\(A,B\\) and \\(C\\) that we used before. A&lt;-c(&quot;shirt&quot;, &quot;shoes&quot;, &quot;laces&quot;) #Defining set A B&lt;-c(&quot;jacket&quot;, &quot;trousers&quot;, &quot;laces&quot;) #Defining set B A_B&lt;-intersect(A,B) A_B ## [1] &quot;laces&quot; C&lt;-c(&quot;shirt&quot;, &quot;socks&quot;, &quot;skirt&quot;, &quot;shirt&quot;) #Defining set C A_B_C&lt;-intersect(A_B,C) A_B_C ## character(0) As we did with ‘union’, it is necessary to perform the operation two times. Note that the set \\(A \\cap B \\cap C\\) is an empty set. It means that there isn’t any element common to all three sets. Note: If \\(A \\cap B\\) = \\(\\Phi\\), than we say that events \\(A\\) and \\(B\\) are mutually exclusive or disjoint. 2.2.3 Complement The complement of a set simply refers to the elements that are not in that set. However, the complement consider a set and the sample space. To illustrate, if the gray circle below is set \\(A\\), then the complement of \\(A\\) is everything else. The complent of \\(A\\) is denoted \\(A^{c}\\) and defined as the difference between \\(S\\) and \\(A\\): \\(S-A = A^{c}= \\{e_i \\in S | e_i \\notin A\\} \\). Note that if the complement of a set is related to another set, \\(A\\) and \\(B\\) for example, it’s termed difference. The difference between two sets correspond to the elements that exist in one set but not in the other. It’s important to note that the order of the terms does matter. The difference between \\(A\\) and \\(B\\) results in elements in \\(B\\) that does not exist in \\(A\\). The difference between \\(B\\) and \\(A\\) ate the elements in \\(A\\) but not in \\(B\\). So as the previous operations, R has the ‘setdiff’ function that calculates it. A&lt;-c(&quot;shirt&quot;, &quot;shoes&quot;, &quot;laces&quot;) #Defining set A B&lt;-c(&quot;jacket&quot;, &quot;trousers&quot;, &quot;laces&quot;) #Defining set B setdiff(A,B) ## [1] &quot;shirt&quot; &quot;shoes&quot; setdiff(B,A) ## [1] &quot;jacket&quot; &quot;trousers&quot; There are other notations for the complement: \\(\\overline{A}\\) and \\(A^{&#39;}\\) are some other options. 2.2.4 Example Two coins are tossed. \\(Let= \\left \\{ \\begin{array}{ll} A: &amp; same\\ face;\\\\ B: &amp; first\\ coin\\ =heads.\\end{array} \\right. \\) Determine the following events: \\(A \\cup B\\) \\(A \\cap B\\) \\(A^{c}\\) \\(B^{c}\\) \\((A \\cup B)^{c}\\) \\((A \\cap B)^{c}\\) \\(A^{c} \\cap B^{c}\\) \\(A^{c} \\cup B^{c}\\) \\(B-A\\) \\(A-B\\) \\(A^{c} \\cap B\\) \\(B^{c} \\cap A\\) Solutions Let’s first define all our sets: Sample set \\(S\\) coin_1&lt;-c(&#39;heads&#39;,&#39;tails&#39;) coin_2&lt;-c(&#39;heads&#39;,&#39;tails&#39;) combine &lt;- function(..., prefix = &quot;(&quot;, suffix=&#39;)&#39;, sep = &quot;,&quot;) { paste0(prefix, levels(interaction(..., sep = sep)), suffix) } #This is the same function we used for our table events for the two dice, in the #beginning of this chapter S&lt;-matrix(combine(coin_1,coin_2), nrow=2, ncol=2, dimnames = list(c(&#39;Coin 1&#39;, &#39;Coin 2&#39;), c(&#39;Coin 1&#39;, &#39;COin 2&#39;))) #This will create a 2x2 matrix with all possible combinations. S ## Coin 1 COin 2 ## Coin 1 &quot;(heads,heads)&quot; &quot;(heads,tails)&quot; ## Coin 2 &quot;(tails,heads)&quot; &quot;(tails,tails)&quot; So, our sample space is: \\(S= \\{(heads,heads),(tails,head),(heads,tails),(tails,tails)\\}\\) And our sets \\(A\\) and \\(B\\) are: \\(A=\\{(heads,heads),(tails,tails)\\}\\\\ B=\\{(heads,heads),(heads,tails)\\}\\) A&lt;-c(&#39;(heads,heads)&#39;, &#39;(tails,tails)&#39;) B&lt;-c(&#39;(heads,heads)&#39;, &#39;(heads,tails)&#39;) Now the solutions: \\(A \\cup B=\\{(heads,heads),(tails,tails),(heads,tails)\\}\\) union(A,B) ## [1] &quot;(heads,heads)&quot; &quot;(tails,tails)&quot; &quot;(heads,tails)&quot; \\(A \\cap B=\\{(heads,heads)\\}\\) intersect(A,B) ## [1] &quot;(heads,heads)&quot; \\(A^{c}=\\{(tails,heads),(heads,tails)\\}\\) #It&#39;s necessary to use &#39;as.vector&#39; here, since S is a matrix. This makes it #&quot;behaves like a set&quot;. #Also, remember that if we want to know the elements in S that are not in A, #we need to subtract A from S. setdiff(as.vector(S),A) ## [1] &quot;(tails,heads)&quot; &quot;(heads,tails)&quot; \\(B^{c}=\\{(tails,heads),(tails,tails)\\}\\) setdiff(as.vector(S),B) ## [1] &quot;(tails,heads)&quot; &quot;(tails,tails)&quot; \\((A \\cup B)^{c}=\\{(tails, heads)\\}\\) AUB&lt;-union(A,B) setdiff(as.vector(S),AUB) ## [1] &quot;(tails,heads)&quot; #We can achieve the same result using the union function inside setdiff function: setdiff(as.vector(S), union(A,B)) ## [1] &quot;(tails,heads)&quot; \\((A \\cap B)^{c}=\\{(tails, heads), (heads,tails),(tails,tails)\\}\\) A_B&lt;-intersect(A,B) setdiff(as.vector(S), A_B) ## [1] &quot;(tails,heads)&quot; &quot;(heads,tails)&quot; &quot;(tails,tails)&quot; #As above, we can use one function inside the other: setdiff(as.vector(S), intersect(A,B)) ## [1] &quot;(tails,heads)&quot; &quot;(heads,tails)&quot; &quot;(tails,tails)&quot; \\(A^{c} \\cap B^{C}=\\{(tails,heads)\\}\\) Ac&lt;-setdiff(as.vector(S),A) Bc&lt;-setdiff(as.vector(S),B) intersect(Ac,Bc) ## [1] &quot;(tails,heads)&quot; #Or: intersect(setdiff(as.vector(S),A),setdiff(as.vector(S),B)) ## [1] &quot;(tails,heads)&quot; \\(A^{c} \\cup B^{C}=\\{(tails,heads),(heads,tails),(tails,tails)\\}\\) #It wasn&#39;t necessary to create Ac and Bc vectors/sets again, since we created them #previously. Ac&lt;-setdiff(as.vector(S),A) Bc&lt;-setdiff(as.vector(S),B) union(Ac,Bc) ## [1] &quot;(tails,heads)&quot; &quot;(heads,tails)&quot; &quot;(tails,tails)&quot; #Or: union(setdiff(as.vector(S),A),setdiff(as.vector(S),B)) ## [1] &quot;(tails,heads)&quot; &quot;(heads,tails)&quot; &quot;(tails,tails)&quot; \\(B-A=\\{(heads,tails)\\}\\) setdiff(B,A) ## [1] &quot;(heads,tails)&quot; \\(A-B=\\{(tails,tails)\\}\\) setdiff(A,B) ## [1] &quot;(tails,tails)&quot; 11.\\(A^{c} \\cap B=\\{(heads, tails)\\}\\) #Again, it wasn&#39;t necessary to create Ac vector/set again, since we created them #previously. It&#39;s just for fixation. Ac&lt;-setdiff(as.vector(S),A) intersect(Ac,B) ## [1] &quot;(heads,tails)&quot; 12.\\(B^{c} \\cap A=\\{(tails,tails)\\}\\) Bc&lt;-setdiff(as.vector(S),B) intersect(Bc,A) ## [1] &quot;(tails,tails)&quot; "],
["fundamental-properties-of-set-operations.html", "2.3 Fundamental Properties of Set Operations", " 2.3 Fundamental Properties of Set Operations The operations union \\(\\cup\\) and \\(\\ \\cap\\), above, have some identities or ‘laws’ with well established names. Making \\(A,B\\) and \\(C\\) sets of events related to a sample space \\(S\\), the following ‘laws’ can be defined: Idempotent: \\(A \\cup A = A\\) \\(A \\cap A = A\\) #Let&#39;s make A = {(1,2,3,4,5,6)} A&lt;-1:6 AUA&lt;-union(A,A) A_A&lt;-intersect(A,A) A ## [1] 1 2 3 4 5 6 AUA ## [1] 1 2 3 4 5 6 A_A ## [1] 1 2 3 4 5 6 Commutative: \\(A \\cup B = B \\cup A\\) \\(A \\cap B = B \\cap A\\) #We already have A, so let&#39;s create B: B&lt;-4:9 AUB&lt;-union(A,B) BUA&lt;-union(B,A) #The &#39;union&#39; function doesn&#39;t provide an ordered vector, so we use the &#39;sort&#39; fuction #to order BUA set to make it easier to compare: AUB ## [1] 1 2 3 4 5 6 7 8 9 sort(BUA) ## [1] 1 2 3 4 5 6 7 8 9 Associative: \\(A \\cap (B \\cap C) = (A \\cap B) \\cap C\\) \\(A \\cup (B \\cup C) = (A \\cup B) \\cup C\\) #Let&#39;s create the last vector/set: C&lt;-3:8 #You can write the command below in separate, as we did in examples before. However, #now, they&#39;ll be written in a sigle command. #For the intersection: intersect(A,intersect(B,C)) ## [1] 4 5 6 intersect(intersect(A,B), C) ## [1] 4 5 6 #For the union: union(A,union(B,C)) ## [1] 1 2 3 4 5 6 7 8 9 union(union(A,B),C) ## [1] 1 2 3 4 5 6 7 8 9 Distributive: \\(A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)\\) \\(A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C)\\) #As before, the codes will be written more starightforward #For the first item: union(A, intersect(B,C)) ## [1] 1 2 3 4 5 6 7 8 intersect(union(A,B), union(A,C)) ## [1] 1 2 3 4 5 6 7 8 #And for the second: intersect(A, union(B,C)) ## [1] 3 4 5 6 union(intersect(A,B), intersect(A,C)) ## [1] 4 5 6 3 #You can sort the second to make the comparison easier: intersect(A, union(B,C)) ## [1] 3 4 5 6 sort(union(intersect(A,B), intersect(A,C))) ## [1] 3 4 5 6 Absortion: \\(A \\cup (A \\cap B)=A\\) \\(A \\cap (A \\cup B)=A\\) #For the union: union(A, intersect(A,B)) ## [1] 1 2 3 4 5 6 A ## [1] 1 2 3 4 5 6 #For the intersection: intersect(A, union(A,B)) ## [1] 1 2 3 4 5 6 A ## [1] 1 2 3 4 5 6 Identity: \\(A \\cap S = A\\) - Remember de S is our notation for sample space. \\(A \\cup S = S\\) \\(A \\cap \\Phi = \\Phi\\) - Remember that \\(\\Phi\\) is our notation for the empty set. You can also find the empty defined as \\(\\emptyset\\) and \\(\\varnothing\\). \\(A \\cup \\Phi = A\\) #Let&#39;s create both sets. For simplicty matters S&lt;-c(&quot;Identity&quot;, &quot;Associative&quot;, &quot;Distributive&quot;, &quot;Absortion&quot;, &quot;Idempotent&quot;, &quot;Commutative&quot;) A&lt;-c(&quot;Associative&quot;,&quot;Absortion&quot;,&quot;Commutative&quot;) O&lt;-c() #The empty set intersect(A,S) ## [1] &quot;Associative&quot; &quot;Absortion&quot; &quot;Commutative&quot; union(A,S) ## [1] &quot;Associative&quot; &quot;Absortion&quot; &quot;Commutative&quot; &quot;Identity&quot; ## [5] &quot;Distributive&quot; &quot;Idempotent&quot; intersect(A,O) ## NULL union(A,O) ## [1] &quot;Associative&quot; &quot;Absortion&quot; &quot;Commutative&quot; Complement \\(S^{c} = \\Phi\\) \\(\\Phi^{c}=S\\) \\(A \\cap A^{c} = \\Phi\\) \\(A \\cup A^{c} = S\\) \\((A^{c})^{c} = A\\) setdiff(O,S) ## NULL setdiff(S,O) ## [1] &quot;Identity&quot; &quot;Associative&quot; &quot;Distributive&quot; &quot;Absortion&quot; ## [5] &quot;Idempotent&quot; &quot;Commutative&quot; intersect(A, setdiff(S,A)) ## character(0) # Remember that the complement of &#39;A&#39; related is related # to the Sample Space &#39;S&#39;. So it&#39;s the difference between # &#39;S&#39; and &#39;A&#39;: S-A. Which is all elements that are in &#39;S&#39; # but not in &#39;A&#39;. union(A,setdiff(S,A)) ## [1] &quot;Associative&quot; &quot;Absortion&quot; &quot;Commutative&quot; &quot;Identity&quot; ## [5] &quot;Distributive&quot; &quot;Idempotent&quot; setdiff(S,setdiff(S,A)) ## [1] &quot;Associative&quot; &quot;Absortion&quot; &quot;Commutative&quot; I want to break down the last property of this law, \\((A^{c})^{c} = A\\) to make it clearer (both mathematically and in R). Note that \\((A^{c})^{c}=S-(A^{c})\\) and that \\(A^{c}=S-A\\). So, \\((A^{c})^{c} = S-(S-A)\\). That said: # Let&#39;s do it inside out. A_complement&lt;-setdiff(S,A) # S-A A_complement ## [1] &quot;Identity&quot; &quot;Distributive&quot; &quot;Idempotent&quot; setdiff(S,A_complement) # S-(S-A) ## [1] &quot;Associative&quot; &quot;Absortion&quot; &quot;Commutative&quot; The principle of duality (De Morgan’s Law): \\((A \\cap B)^{c}=A^{c} \\cup B^{c}\\) \\((A \\cup B)^{c}=A^{c} \\cap B^{c}\\) I will not provide the “proof” for this law here, since it’s easily verified. It would be nice if you try it for yourself to check your understanding. However, I’ll put it in the end of this ‘book’. 2.3.1 The Principle of Inclusion-Exclusion (PIE, for short) I decided to make a separated topic for this principle because of its importance and the need for a longer explanation. The principle of inclusion-exclusion is an equation relating to the counting of the sizes of two sets and their union. It states that if A and B are two (finite) sets, and they are not disjoint (disjoint sets are sets that have no elements in common), then the sum of its elementes would be: \\(|A \\cup B|= |A|+|B|-|A| \\cap |B|\\) Need to note that, this principle is related to the counting of elements and not with the resulting set. When we write a set between bars, \\(|A|\\) we are refering to its cardinality, or simply the number of elements it contains. For example, if \\(A=\\{Pink, Blue, Red, Purple, Green\\}\\), then its cardinality is \\(|A|=5\\). To illustrate the principle let’s consider the following: Let: \\(A=\\{Pink, Blue, Red, Purple, Green\\}\\) and \\(B=\\{Yellow, Blue, Red, Light\\ Blue, Green, Ochre, Silver\\}\\). Then: \\(A \\cup B=\\{Pink, Blue, Red, Purple, Green, Yellow, Light\\ Blue, Ochre, Silver\\}\\). The cadinality of this sets would be: \\(|A|=5\\), \\(|B|=7\\) and \\(|A \\cup B|=9\\) A&lt;-c(&#39;Pink&#39;, &#39;Blue&#39;, &#39;Red&#39;, &#39;Purple&#39;, &#39;Green&#39;) B&lt;-c(&#39;Yellow&#39;, &#39;Blue&#39;, &#39;Red&#39;, &#39;Light Blue&#39;, &#39;Green&#39;, &#39;Ochre&#39;, &#39;Silver&#39;) card_A&lt;-length(A) # &#39;length&#39; function count the number of elements in a vector. card_B&lt;-length(B) AuB&lt;-union(A,B) card_AuB&lt;-length(AuB) A ## [1] &quot;Pink&quot; &quot;Blue&quot; &quot;Red&quot; &quot;Purple&quot; &quot;Green&quot; card_A ## [1] 5 B ## [1] &quot;Yellow&quot; &quot;Blue&quot; &quot;Red&quot; &quot;Light Blue&quot; &quot;Green&quot; ## [6] &quot;Ochre&quot; &quot;Silver&quot; card_B ## [1] 7 AuB ## [1] &quot;Pink&quot; &quot;Blue&quot; &quot;Red&quot; &quot;Purple&quot; &quot;Green&quot; ## [6] &quot;Yellow&quot; &quot;Light Blue&quot; &quot;Ochre&quot; &quot;Silver&quot; card_AuB ## [1] 9 Using PIE: \\(|A \\cup B|= |A|+|B|-|A| \\cap |B| \\therefore |A \\cup B|= 5+7-3 \\therefore |A \\cup B|=9.\\) length(A)+length(B)-length(intersect(A,B)) ## [1] 9 It seems pretty lame, since we know the size and elements of each set and we can simply call it in the console to check. But it has some practical applications, specially whe the sets are not very well defined. I’ll show an example below. The PIE with two sets is in its most simple form and, hell, what does it do? When you are counting sets and add them up, let’s keep two for awhile, and they have some intersection, you are counting some elements twice. To eliminate this problem, we subtract the number of elements of their intersection. However, what of we have three sets? Then it reads: \\(|A \\cup B \\cup C|=|A|+|B|+|C|-|A \\cap B|-|A \\cap C|-|B \\cap C| + |A \\cap B \\cap C|\\) To give you a better understanding of what “is happening” during the calculations above, let’s use some diagrams to make more simple. This is what happens when you do \\(|A|+|B|+|C|\\). Because you’re adding up the number of elements of the sets, the intersections are counted more than once. To remove these elements that were counted more than once, we subtract all the intersections, \\(|A|+|B|+|C|-|A \\cap B|-|A \\cap C|-|B \\cap C|\\); Finally, we add the intersection of the three sets: \\(|A|+|B|+|C|-|A \\cap B|-|A \\cap C|-|B \\cap C| + |A \\cap B \\cap C|\\), so every set and operations are counted only once. We can generalize this for n sets, but it’s a little more complex and will not be covered here (perhaps in next review). But it can be easily found on Google. As I said before, it seems pretty obvious, since we know the sets and can check everything. Sometimes, however, it’s necessary to choose distinct elements from a collection of overlapping sets and, in this case, things don’t look so simplistic. Take a look in the next example: During a survey, 200 people are asked about which forms of transport the had used in the last month. 150 of them used trains, 80 used bike or trains and 180 used both. That said: How many people had used bike in the last month? How many had not used either form of transport? This can be answered using the inclusion-exclusion principle for two sets. \\(Let = \\left\\{ \\begin{array}{ll} A: people\\ that\\ used\\ trains\\\\ B: people\\ that\\ used\\ bikes \\end{array} \\right. \\) From the information above we have the following: \\(|A| = 150 \\\\ |B|=? \\\\ |A| \\cap |B| = 80 \\\\ |A| \\cup |B|=180\\) PIE: \\(|A \\cup B|=|A|+|B|-|A \\cap B|\\) Substitute the values: \\(180=150+ |B|-80\\ \\therefore |B|=180-150+80 \\therefore |B|=70.\\) So, 70 people used bike last month. The second question is more simple: if 200 people were interviwed and 180 used trains or bike, then: \\(200-180=20\\) "],
["exercises.html", "Exercises", " Exercises Solved Exercises Three coins are tossed. Construct the sample space and define the following events: same faces; heads on second coin; tails on second and third coins; heads on the first and tails in the last. # Let&#39;s create the coins vectors: C1&lt;-c(&#39;heads&#39;, &#39;tails&#39;) C2&lt;-c(&#39;heads&#39;, &#39;tails&#39;) C3&lt;-c(&#39;heads&#39;, &#39;tails&#39;) # CREATE THE SAMPLE SPACE: # The sample space can be created by two ways: # 1 - expand.grid. expand.grid(&quot;coin 1&quot;=C1, &quot;coin 2&quot;=C2, &quot;coin 3&quot;=C3) ## coin 1 coin 2 coin 3 ## 1 heads heads heads ## 2 tails heads heads ## 3 heads tails heads ## 4 tails tails heads ## 5 heads heads tails ## 6 tails heads tails ## 7 heads tails tails ## 8 tails tails tails # You can use the expand grid to see how many rows and cols yor matrix should have. # 2 - Our previous function combine &lt;- function(..., prefix = &quot;&quot;, suffix=&#39;&#39;, sep = &quot;, &quot;) { # I added a space between paste0(prefix, levels(interaction(..., sep = sep)), suffix) # elements and removed the # parathesis } S&lt;-matrix(combine(C1,C2,C3), nrow=8, ncol=1) S ## [,1] ## [1,] &quot;heads, heads, heads&quot; ## [2,] &quot;tails, heads, heads&quot; ## [3,] &quot;heads, tails, heads&quot; ## [4,] &quot;tails, tails, heads&quot; ## [5,] &quot;heads, heads, tails&quot; ## [6,] &quot;tails, heads, tails&quot; ## [7,] &quot;heads, tails, tails&quot; ## [8,] &quot;tails, tails, tails&quot; # The second approach makes the sample space more interactive when needed. Below you # can see it. # NUMBER OF EVENTS WITH THE SAME FACES: hhh&lt;-grep(&quot;heads, heads, heads&quot;, S) # grep function looks for a specific string inside a # vector or text. If it finds a match, it returns the # the position of the match, not the result. Hiwever # if you put value=T in the function, it returns the value. ttt&lt;-grep(&quot;tails, tails, tails&quot;, S) # These are all positions of the values inside the vector or matrix. hhh ## [1] 1 ttt ## [1] 8 same_faces&lt;-length(hhh)+length(ttt) # We add the lengths of the vectors, so we have the total # value found. # That said, the number of outcomes with same faces: same_faces ## [1] 2 # HEADS IN THE FIRST COIN: hxx&lt;-grep(&quot;^heads&quot;, S) # The operator ^ indicates to fetch every string beginning with heads. # the number of outcomes with same faces: first_head&lt;-length(hxx) first_head ## [1] 4 # TAILS ON 2ND AND 3RD xtt&lt;-grep(&#39;tails, tails$&#39;,S) # The operator $ tells to fetch only values that ends with # tails, tails. # The number of outcomes with tails in 2nd and 3rd coin is given by: tails_2nd_3rd&lt;-length(xtt) tails_2nd_3rd ## [1] 2 # HEADS ON FIRST AND TAILS ON 3RD hxt&lt;-grep(&quot;^heads.*tails$&quot;, S, value=T) # The combination of the operators ^ and .* tells the # function to fetch every value begining with heads # and ending with tails. # Since the option value=T was inserted in the function above, hxt will return the values # requested. It was just to show how it works. hxt ## [1] &quot;heads, heads, tails&quot; &quot;heads, tails, tails&quot; # The number of events with heads on 1st and tails on 3rd: length(hxt) ## [1] 2 Proposed Exercises Given the birth of 3 children, considering their sex, define the following events two children of the same sex; at least one male child; no more than two female children \\(~\\) Considering \\(A, B\\) and \\(C\\) as events of a sample space \\(S\\), define the events below using the set operations you previously learned. only \\(A\\) happens; \\(A\\) and \\(C\\) happens but not \\(B\\); All events happen; At least one event happens; No event happens; No more than two events happen. "],
["important-notes-1.html", "Important Notes", " Important Notes "],
["references.html", "References", " References "],
["solutions-for-sample-space-chapter.html", "Solutions for Sample Space Chapter", " Solutions for Sample Space Chapter "]
]
